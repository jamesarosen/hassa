#!/usr/bin/env bash
# pseudo-pr: push branch, wait for CI to pass, fast-forward merge to target
#
# Usage: pseudo-pr [--target <branch>] [--allow-no-ci] [--skip-quality-gate]
#
# Environment:
#   PSEUDO_PR_TARGET     Branch to merge into (default: main)
#   PSEUDO_PR_CI_WAIT    Seconds to wait for CI runs to appear (default: 60)

set -euo pipefail

# ── Config ────────────────────────────────────────────────────────────────────
TARGET="${PSEUDO_PR_TARGET:-main}"
CI_WAIT="${PSEUDO_PR_CI_WAIT:-60}"
ALLOW_NO_CI=0
SKIP_QG=0

_usage() {
  cat <<'EOF'
Usage: pseudo-pr [--target <branch>] [--allow-no-ci] [--skip-quality-gate]

Push the current branch, wait for CI to pass, fast-forward merge to target.

Options:
  --target <branch>      Branch to merge into (default: $PSEUDO_PR_TARGET or main)
  --allow-no-ci          Merge even if no CI runs appear (for repos with no CI)
  --skip-quality-gate    Skip bin/quality-gate.sh (useful when the caller already ran it)
  --help                 Show this help

Environment:
  PSEUDO_PR_TARGET       Same as --target
  PSEUDO_PR_CI_WAIT      Seconds to wait for CI runs to appear (default: 60)
EOF
}

while [[ $# -gt 0 ]]; do
  case $1 in
    --target)            TARGET="$2"; shift 2 ;;
    --allow-no-ci)       ALLOW_NO_CI=1; shift ;;
    --skip-quality-gate) SKIP_QG=1; shift ;;
    --help)              _usage; exit 0 ;;
    *) printf 'Unknown flag: %s\n\n' "$1" >&2; _usage >&2; exit 1 ;;
  esac
done

# ── Colors (only when stdout is a terminal) ───────────────────────────────────
if [[ -t 1 ]]; then
  RED='\033[0;31m' GREEN='\033[0;32m' YELLOW='\033[1;33m' BOLD='\033[1m' NC='\033[0m'
else
  RED='' GREEN='' YELLOW='' BOLD='' NC=''
fi

info()  { printf "${GREEN}==>${NC} ${BOLD}%s${NC}\n" "$*"; }
warn()  { printf "${YELLOW}warn:${NC} %s\n" "$*" >&2; }
error() { printf "${RED}error:${NC} %s\n" "$*" >&2; exit 1; }

# ── Exit trap ─────────────────────────────────────────────────────────────────
phase="init"
sha=""
_on_exit() {
  local ec=$?
  [[ $ec -eq 0 ]] && return
  [[ "$phase" == "init" ]] && return  # failed before push; nothing to recover
  printf "${YELLOW}hint:${NC} failed during: %s\n" "$phase" >&2
  if [[ -n "$sha" ]]; then
    printf "  pushed:  origin/%s  (%s)\n" "$branch" "$sha" >&2
    printf "  to retry: git checkout %s && pseudo-pr\n" "$branch" >&2
    printf "  ci logs:  gh run list --branch %s\n" "$branch" >&2
  fi
}
trap _on_exit EXIT

# ── Preflight ─────────────────────────────────────────────────────────────────
command -v gh  &>/dev/null || error "gh CLI not found — install from https://cli.github.com"
command -v jq  &>/dev/null || error "jq not found — brew install jq"
command -v git &>/dev/null || error "git not found"

branch=$(git branch --show-current)
[[ -z "$branch" ]]           && error "Detached HEAD — check out a branch first"
[[ "$branch" == "$TARGET" ]] && error "Already on $TARGET — create a feature branch first"

# Allow untracked files; fail only on tracked uncommitted changes
modified=$(git status --porcelain | grep -v '^??' || true)
[[ -n "$modified" ]] && error "Uncommitted tracked changes — commit or stash first"

repo=$(gh repo view --json nameWithOwner -q .nameWithOwner)
info "Shipping ${BOLD}$branch${NC} → ${BOLD}$TARGET${NC}  ($repo)"

# ── Quality gate ──────────────────────────────────────────────────────────────
if [[ "$SKIP_QG" -eq 0 && -f "bin/quality-gate.sh" ]]; then
  phase="quality gate"
  info "Running quality gate..."
  bin/quality-gate.sh || error "Quality gate failed"
fi

# ── Push ──────────────────────────────────────────────────────────────────────
phase="push"
info "Pushing $branch..."
git push -u origin HEAD
sha=$(git rev-parse HEAD)

# ── Wait for CI runs to appear ────────────────────────────────────────────────
phase="waiting for CI"
info "Waiting for CI to start (up to ${CI_WAIT}s)..."
elapsed=0
runs_json="[]"
while true; do
  runs_json=$(
    gh run list --commit "$sha" --branch "$branch" \
      --json databaseId,name,status,url --limit 20 \
    | jq '[.[] | select(.status != "cancelled")]'
  )
  count=$(printf '%s' "$runs_json" | jq 'length')
  if [[ "$count" -gt 0 ]]; then
    info "Found $count CI run(s)"
    break
  fi
  if [[ "$elapsed" -ge "$CI_WAIT" ]]; then
    if [[ "$ALLOW_NO_CI" -eq 1 ]]; then
      warn "No CI runs appeared after ${CI_WAIT}s — merging without CI gate (--allow-no-ci)"
      break
    else
      error "No CI runs appeared after ${CI_WAIT}s. CI may not have started yet, or this repo has no CI. Pass --allow-no-ci to merge anyway."
    fi
  fi
  sleep 5
  elapsed=$((elapsed + 5))
done

# ── Watch each run ────────────────────────────────────────────────────────────
phase="watching CI"
failed_runs=()
while IFS= read -r run_id; do
  run_name=$(printf '%s' "$runs_json" | jq -r --argjson id "$run_id" \
    '.[] | select(.databaseId == $id) | .name')
  run_url=$(printf '%s' "$runs_json" | jq -r --argjson id "$run_id" \
    '.[] | select(.databaseId == $id) | .url')
  info "Watching: $run_name"
  if ! gh run watch "$run_id" --exit-status; then
    ec=$?
    warn "FAILED: $run_name (exit $ec)"
    warn "  $run_url"
    failed_runs+=("$run_name")
  fi
done < <(printf '%s' "$runs_json" | jq -r '.[].databaseId')

if [[ "${#failed_runs[@]}" -gt 0 ]]; then
  error "${#failed_runs[@]} CI run(s) failed: ${failed_runs[*]}"
fi

# ── Merge to target ───────────────────────────────────────────────────────────
phase="merge"
info "Merging $branch → $TARGET..."
git fetch origin "$TARGET"

# Verify fast-forward is possible before touching $TARGET — keeps user on
# their branch if this check fails rather than leaving them stranded on main
git merge-base --is-ancestor "origin/$TARGET" "origin/$branch" \
  || error "Fast-forward not possible — $TARGET has diverged. Rebase first: git rebase origin/$TARGET"

git checkout "$TARGET"
git pull --ff-only origin "$TARGET"
git merge --ff-only "origin/$branch"
git push origin "$TARGET"

# ── Clean up ──────────────────────────────────────────────────────────────────
phase="cleanup"
git push origin --delete "$branch" \
  && info "Deleted remote branch $branch" \
  || warn "Could not delete remote branch $branch — delete manually"
git branch -d "$branch" \
  && info "Deleted local branch $branch" \
  || warn "Could not delete local branch $branch — delete manually"

info "Done! $branch shipped to $TARGET"
